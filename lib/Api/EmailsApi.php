<?php
/**
 * EmailsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * BombBomb
 *
 * We make it easy to build relationships using simple videos.
 *
 * OpenAPI spec version: 2.0.831
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * EmailsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class EmailsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createPrintingPressEmail
     *
     * Create an Email with Printing Press
     *
     * @param  string $templateId The template id to be printed. (required)
     * @param  string $content The content of the email. (required)
     * @param  string $emailId The email id to be printed to. (optional)
     * @param  string $videoId A video to replace video place holders with. (optional)
     * @param  string $subjectLine The subject line to be printed. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createPrintingPressEmail($templateId, $content, $emailId = null, $videoId = null, $subjectLine = null)
    {
        $this->createPrintingPressEmailWithHttpInfo($templateId, $content, $emailId, $videoId, $subjectLine);
    }

    /**
     * Operation createPrintingPressEmailWithHttpInfo
     *
     * Create an Email with Printing Press
     *
     * @param  string $templateId The template id to be printed. (required)
     * @param  string $content The content of the email. (required)
     * @param  string $emailId The email id to be printed to. (optional)
     * @param  string $videoId A video to replace video place holders with. (optional)
     * @param  string $subjectLine The subject line to be printed. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPrintingPressEmailWithHttpInfo($templateId, $content, $emailId = null, $videoId = null, $subjectLine = null)
    {
        $returnType = '';
        $request = $this->createPrintingPressEmailRequest($templateId, $content, $emailId, $videoId, $subjectLine);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createPrintingPressEmailAsync
     *
     * Create an Email with Printing Press
     *
     * @param  string $templateId The template id to be printed. (required)
     * @param  string $content The content of the email. (required)
     * @param  string $emailId The email id to be printed to. (optional)
     * @param  string $videoId A video to replace video place holders with. (optional)
     * @param  string $subjectLine The subject line to be printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPrintingPressEmailAsync($templateId, $content, $emailId = null, $videoId = null, $subjectLine = null)
    {
        return $this->createPrintingPressEmailAsyncWithHttpInfo($templateId, $content, $emailId, $videoId, $subjectLine)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPrintingPressEmailAsyncWithHttpInfo
     *
     * Create an Email with Printing Press
     *
     * @param  string $templateId The template id to be printed. (required)
     * @param  string $content The content of the email. (required)
     * @param  string $emailId The email id to be printed to. (optional)
     * @param  string $videoId A video to replace video place holders with. (optional)
     * @param  string $subjectLine The subject line to be printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPrintingPressEmailAsyncWithHttpInfo($templateId, $content, $emailId = null, $videoId = null, $subjectLine = null)
    {
        $returnType = '';
        $request = $this->createPrintingPressEmailRequest($templateId, $content, $emailId, $videoId, $subjectLine);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPrintingPressEmail'
     *
     * @param  string $templateId The template id to be printed. (required)
     * @param  string $content The content of the email. (required)
     * @param  string $emailId The email id to be printed to. (optional)
     * @param  string $videoId A video to replace video place holders with. (optional)
     * @param  string $subjectLine The subject line to be printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createPrintingPressEmailRequest($templateId, $content, $emailId = null, $videoId = null, $subjectLine = null)
    {
        // verify the required parameter 'templateId' is set
        if ($templateId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $templateId when calling createPrintingPressEmail'
            );
        }
        // verify the required parameter 'content' is set
        if ($content === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content when calling createPrintingPressEmail'
            );
        }

        $resourcePath = '/emails/print';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($templateId !== null) {
            $formParams['templateId'] = ObjectSerializer::toFormValue($templateId);
        }
        // form params
        if ($content !== null) {
            $formParams['content'] = ObjectSerializer::toFormValue($content);
        }
        // form params
        if ($emailId !== null) {
            $formParams['emailId'] = ObjectSerializer::toFormValue($emailId);
        }
        // form params
        if ($videoId !== null) {
            $formParams['videoId'] = ObjectSerializer::toFormValue($videoId);
        }
        // form params
        if ($subjectLine !== null) {
            $formParams['subjectLine'] = ObjectSerializer::toFormValue($subjectLine);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllTemplatesForCurrentUser
     *
     * Get all user templates
     *
     * @param  bool $quickSendOnly Whether to return only quick send templates. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getAllTemplatesForCurrentUser($quickSendOnly = null)
    {
        $this->getAllTemplatesForCurrentUserWithHttpInfo($quickSendOnly);
    }

    /**
     * Operation getAllTemplatesForCurrentUserWithHttpInfo
     *
     * Get all user templates
     *
     * @param  bool $quickSendOnly Whether to return only quick send templates. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllTemplatesForCurrentUserWithHttpInfo($quickSendOnly = null)
    {
        $returnType = '';
        $request = $this->getAllTemplatesForCurrentUserRequest($quickSendOnly);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getAllTemplatesForCurrentUserAsync
     *
     * Get all user templates
     *
     * @param  bool $quickSendOnly Whether to return only quick send templates. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllTemplatesForCurrentUserAsync($quickSendOnly = null)
    {
        return $this->getAllTemplatesForCurrentUserAsyncWithHttpInfo($quickSendOnly)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllTemplatesForCurrentUserAsyncWithHttpInfo
     *
     * Get all user templates
     *
     * @param  bool $quickSendOnly Whether to return only quick send templates. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllTemplatesForCurrentUserAsyncWithHttpInfo($quickSendOnly = null)
    {
        $returnType = '';
        $request = $this->getAllTemplatesForCurrentUserRequest($quickSendOnly);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllTemplatesForCurrentUser'
     *
     * @param  bool $quickSendOnly Whether to return only quick send templates. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllTemplatesForCurrentUserRequest($quickSendOnly = null)
    {

        $resourcePath = '/emails/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($quickSendOnly !== null) {
            $queryParams['quickSendOnly'] = ObjectSerializer::toQueryValue($quickSendOnly);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmailTracking
     *
     * Get Email Tracking
     *
     * @param  string $emailId ID of the email (required)
     * @param  string $jobId ID of the Job (or null for all jobs) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getEmailTracking($emailId, $jobId = null)
    {
        $this->getEmailTrackingWithHttpInfo($emailId, $jobId);
    }

    /**
     * Operation getEmailTrackingWithHttpInfo
     *
     * Get Email Tracking
     *
     * @param  string $emailId ID of the email (required)
     * @param  string $jobId ID of the Job (or null for all jobs) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmailTrackingWithHttpInfo($emailId, $jobId = null)
    {
        $returnType = '';
        $request = $this->getEmailTrackingRequest($emailId, $jobId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getEmailTrackingAsync
     *
     * Get Email Tracking
     *
     * @param  string $emailId ID of the email (required)
     * @param  string $jobId ID of the Job (or null for all jobs) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailTrackingAsync($emailId, $jobId = null)
    {
        return $this->getEmailTrackingAsyncWithHttpInfo($emailId, $jobId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmailTrackingAsyncWithHttpInfo
     *
     * Get Email Tracking
     *
     * @param  string $emailId ID of the email (required)
     * @param  string $jobId ID of the Job (or null for all jobs) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailTrackingAsyncWithHttpInfo($emailId, $jobId = null)
    {
        $returnType = '';
        $request = $this->getEmailTrackingRequest($emailId, $jobId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmailTracking'
     *
     * @param  string $emailId ID of the email (required)
     * @param  string $jobId ID of the Job (or null for all jobs) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEmailTrackingRequest($emailId, $jobId = null)
    {
        // verify the required parameter 'emailId' is set
        if ($emailId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $emailId when calling getEmailTracking'
            );
        }

        $resourcePath = '/emails/{emailId}/tracking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($jobId !== null) {
            $queryParams['jobId'] = ObjectSerializer::toQueryValue($jobId);
        }

        // path params
        if ($emailId !== null) {
            $resourcePath = str_replace(
                '{' . 'emailId' . '}',
                ObjectSerializer::toPathValue($emailId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmailTrackingInteractions
     *
     * Get Email Tracking Interactions
     *
     * @param  string $emailId ID of the email (required)
     * @param  string $jobId ID of the Job (or null for all jobs) (optional)
     * @param  string $interactionType Interaction type to order and filter by (optional)
     * @param  string $searchTerm Search term to filer by (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getEmailTrackingInteractions($emailId, $jobId = null, $interactionType = null, $searchTerm = null)
    {
        $this->getEmailTrackingInteractionsWithHttpInfo($emailId, $jobId, $interactionType, $searchTerm);
    }

    /**
     * Operation getEmailTrackingInteractionsWithHttpInfo
     *
     * Get Email Tracking Interactions
     *
     * @param  string $emailId ID of the email (required)
     * @param  string $jobId ID of the Job (or null for all jobs) (optional)
     * @param  string $interactionType Interaction type to order and filter by (optional)
     * @param  string $searchTerm Search term to filer by (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmailTrackingInteractionsWithHttpInfo($emailId, $jobId = null, $interactionType = null, $searchTerm = null)
    {
        $returnType = '';
        $request = $this->getEmailTrackingInteractionsRequest($emailId, $jobId, $interactionType, $searchTerm);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getEmailTrackingInteractionsAsync
     *
     * Get Email Tracking Interactions
     *
     * @param  string $emailId ID of the email (required)
     * @param  string $jobId ID of the Job (or null for all jobs) (optional)
     * @param  string $interactionType Interaction type to order and filter by (optional)
     * @param  string $searchTerm Search term to filer by (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailTrackingInteractionsAsync($emailId, $jobId = null, $interactionType = null, $searchTerm = null)
    {
        return $this->getEmailTrackingInteractionsAsyncWithHttpInfo($emailId, $jobId, $interactionType, $searchTerm)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmailTrackingInteractionsAsyncWithHttpInfo
     *
     * Get Email Tracking Interactions
     *
     * @param  string $emailId ID of the email (required)
     * @param  string $jobId ID of the Job (or null for all jobs) (optional)
     * @param  string $interactionType Interaction type to order and filter by (optional)
     * @param  string $searchTerm Search term to filer by (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailTrackingInteractionsAsyncWithHttpInfo($emailId, $jobId = null, $interactionType = null, $searchTerm = null)
    {
        $returnType = '';
        $request = $this->getEmailTrackingInteractionsRequest($emailId, $jobId, $interactionType, $searchTerm);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmailTrackingInteractions'
     *
     * @param  string $emailId ID of the email (required)
     * @param  string $jobId ID of the Job (or null for all jobs) (optional)
     * @param  string $interactionType Interaction type to order and filter by (optional)
     * @param  string $searchTerm Search term to filer by (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEmailTrackingInteractionsRequest($emailId, $jobId = null, $interactionType = null, $searchTerm = null)
    {
        // verify the required parameter 'emailId' is set
        if ($emailId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $emailId when calling getEmailTrackingInteractions'
            );
        }

        $resourcePath = '/emails/{emailId}/tracking/interactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($jobId !== null) {
            $queryParams['jobId'] = ObjectSerializer::toQueryValue($jobId);
        }
        // query params
        if ($interactionType !== null) {
            $queryParams['interactionType'] = ObjectSerializer::toQueryValue($interactionType);
        }
        // query params
        if ($searchTerm !== null) {
            $queryParams['searchTerm'] = ObjectSerializer::toQueryValue($searchTerm);
        }

        // path params
        if ($emailId !== null) {
            $resourcePath = str_replace(
                '{' . 'emailId' . '}',
                ObjectSerializer::toPathValue($emailId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHourlyEmailTracking
     *
     * Get Hourly Email Tracking
     *
     * @param  string $emailId ID of the email (required)
     * @param  string $jobId ID of the Job (or null for all jobs) (optional)
     * @param  string $interactionType Interaction type to filter by (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getHourlyEmailTracking($emailId, $jobId = null, $interactionType = null)
    {
        $this->getHourlyEmailTrackingWithHttpInfo($emailId, $jobId, $interactionType);
    }

    /**
     * Operation getHourlyEmailTrackingWithHttpInfo
     *
     * Get Hourly Email Tracking
     *
     * @param  string $emailId ID of the email (required)
     * @param  string $jobId ID of the Job (or null for all jobs) (optional)
     * @param  string $interactionType Interaction type to filter by (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHourlyEmailTrackingWithHttpInfo($emailId, $jobId = null, $interactionType = null)
    {
        $returnType = '';
        $request = $this->getHourlyEmailTrackingRequest($emailId, $jobId, $interactionType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getHourlyEmailTrackingAsync
     *
     * Get Hourly Email Tracking
     *
     * @param  string $emailId ID of the email (required)
     * @param  string $jobId ID of the Job (or null for all jobs) (optional)
     * @param  string $interactionType Interaction type to filter by (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHourlyEmailTrackingAsync($emailId, $jobId = null, $interactionType = null)
    {
        return $this->getHourlyEmailTrackingAsyncWithHttpInfo($emailId, $jobId, $interactionType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHourlyEmailTrackingAsyncWithHttpInfo
     *
     * Get Hourly Email Tracking
     *
     * @param  string $emailId ID of the email (required)
     * @param  string $jobId ID of the Job (or null for all jobs) (optional)
     * @param  string $interactionType Interaction type to filter by (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHourlyEmailTrackingAsyncWithHttpInfo($emailId, $jobId = null, $interactionType = null)
    {
        $returnType = '';
        $request = $this->getHourlyEmailTrackingRequest($emailId, $jobId, $interactionType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHourlyEmailTracking'
     *
     * @param  string $emailId ID of the email (required)
     * @param  string $jobId ID of the Job (or null for all jobs) (optional)
     * @param  string $interactionType Interaction type to filter by (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHourlyEmailTrackingRequest($emailId, $jobId = null, $interactionType = null)
    {
        // verify the required parameter 'emailId' is set
        if ($emailId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $emailId when calling getHourlyEmailTracking'
            );
        }

        $resourcePath = '/emails/{emailId}/tracking/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($jobId !== null) {
            $queryParams['jobId'] = ObjectSerializer::toQueryValue($jobId);
        }
        // query params
        if ($interactionType !== null) {
            $queryParams['interactionType'] = ObjectSerializer::toQueryValue($interactionType);
        }

        // path params
        if ($emailId !== null) {
            $resourcePath = str_replace(
                '{' . 'emailId' . '}',
                ObjectSerializer::toPathValue($emailId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLiveFireData
     *
     * Get livefire feed data
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getLiveFireData()
    {
        $this->getLiveFireDataWithHttpInfo();
    }

    /**
     * Operation getLiveFireDataWithHttpInfo
     *
     * Get livefire feed data
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLiveFireDataWithHttpInfo()
    {
        $returnType = '';
        $request = $this->getLiveFireDataRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getLiveFireDataAsync
     *
     * Get livefire feed data
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveFireDataAsync()
    {
        return $this->getLiveFireDataAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLiveFireDataAsyncWithHttpInfo
     *
     * Get livefire feed data
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveFireDataAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->getLiveFireDataRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLiveFireData'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLiveFireDataRequest()
    {

        $resourcePath = '/emails/livefire';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getQuickSendTemplates
     *
     * Get all quicksend templates
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getQuickSendTemplates()
    {
        $this->getQuickSendTemplatesWithHttpInfo();
    }

    /**
     * Operation getQuickSendTemplatesWithHttpInfo
     *
     * Get all quicksend templates
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getQuickSendTemplatesWithHttpInfo()
    {
        $returnType = '';
        $request = $this->getQuickSendTemplatesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getQuickSendTemplatesAsync
     *
     * Get all quicksend templates
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getQuickSendTemplatesAsync()
    {
        return $this->getQuickSendTemplatesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getQuickSendTemplatesAsyncWithHttpInfo
     *
     * Get all quicksend templates
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getQuickSendTemplatesAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->getQuickSendTemplatesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getQuickSendTemplates'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getQuickSendTemplatesRequest()
    {

        $resourcePath = '/emails/quicksend/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTemplateHtmlForTemplateId
     *
     * Get the HTML for a given template
     *
     * @param  string $templateId The id of the template. (required)
     * @param  string $renderVariables Whether to render profile variables in the returned HTML. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getTemplateHtmlForTemplateId($templateId, $renderVariables = null)
    {
        $this->getTemplateHtmlForTemplateIdWithHttpInfo($templateId, $renderVariables);
    }

    /**
     * Operation getTemplateHtmlForTemplateIdWithHttpInfo
     *
     * Get the HTML for a given template
     *
     * @param  string $templateId The id of the template. (required)
     * @param  string $renderVariables Whether to render profile variables in the returned HTML. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTemplateHtmlForTemplateIdWithHttpInfo($templateId, $renderVariables = null)
    {
        $returnType = '';
        $request = $this->getTemplateHtmlForTemplateIdRequest($templateId, $renderVariables);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getTemplateHtmlForTemplateIdAsync
     *
     * Get the HTML for a given template
     *
     * @param  string $templateId The id of the template. (required)
     * @param  string $renderVariables Whether to render profile variables in the returned HTML. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplateHtmlForTemplateIdAsync($templateId, $renderVariables = null)
    {
        return $this->getTemplateHtmlForTemplateIdAsyncWithHttpInfo($templateId, $renderVariables)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTemplateHtmlForTemplateIdAsyncWithHttpInfo
     *
     * Get the HTML for a given template
     *
     * @param  string $templateId The id of the template. (required)
     * @param  string $renderVariables Whether to render profile variables in the returned HTML. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplateHtmlForTemplateIdAsyncWithHttpInfo($templateId, $renderVariables = null)
    {
        $returnType = '';
        $request = $this->getTemplateHtmlForTemplateIdRequest($templateId, $renderVariables);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTemplateHtmlForTemplateId'
     *
     * @param  string $templateId The id of the template. (required)
     * @param  string $renderVariables Whether to render profile variables in the returned HTML. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTemplateHtmlForTemplateIdRequest($templateId, $renderVariables = null)
    {
        // verify the required parameter 'templateId' is set
        if ($templateId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $templateId when calling getTemplateHtmlForTemplateId'
            );
        }

        $resourcePath = '/emails/templates/{templateId}/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($renderVariables !== null) {
            $queryParams['renderVariables'] = ObjectSerializer::toQueryValue($renderVariables);
        }

        // path params
        if ($templateId !== null) {
            $resourcePath = str_replace(
                '{' . 'templateId' . '}',
                ObjectSerializer::toPathValue($templateId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVideoQuickSenderData
     *
     * Get quicksend data
     *
     * @param  string $message A message for the video content. (optional)
     * @param  string $subject A subject for the video content. (optional)
     * @param  string $videoId A video ID. (optional)
     * @param  string $templateId A template ID. (optional)
     * @param  string $commaDelimEmails Comma delimited emails (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getVideoQuickSenderData($message = null, $subject = null, $videoId = null, $templateId = null, $commaDelimEmails = null)
    {
        $this->getVideoQuickSenderDataWithHttpInfo($message, $subject, $videoId, $templateId, $commaDelimEmails);
    }

    /**
     * Operation getVideoQuickSenderDataWithHttpInfo
     *
     * Get quicksend data
     *
     * @param  string $message A message for the video content. (optional)
     * @param  string $subject A subject for the video content. (optional)
     * @param  string $videoId A video ID. (optional)
     * @param  string $templateId A template ID. (optional)
     * @param  string $commaDelimEmails Comma delimited emails (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVideoQuickSenderDataWithHttpInfo($message = null, $subject = null, $videoId = null, $templateId = null, $commaDelimEmails = null)
    {
        $returnType = '';
        $request = $this->getVideoQuickSenderDataRequest($message, $subject, $videoId, $templateId, $commaDelimEmails);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getVideoQuickSenderDataAsync
     *
     * Get quicksend data
     *
     * @param  string $message A message for the video content. (optional)
     * @param  string $subject A subject for the video content. (optional)
     * @param  string $videoId A video ID. (optional)
     * @param  string $templateId A template ID. (optional)
     * @param  string $commaDelimEmails Comma delimited emails (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVideoQuickSenderDataAsync($message = null, $subject = null, $videoId = null, $templateId = null, $commaDelimEmails = null)
    {
        return $this->getVideoQuickSenderDataAsyncWithHttpInfo($message, $subject, $videoId, $templateId, $commaDelimEmails)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVideoQuickSenderDataAsyncWithHttpInfo
     *
     * Get quicksend data
     *
     * @param  string $message A message for the video content. (optional)
     * @param  string $subject A subject for the video content. (optional)
     * @param  string $videoId A video ID. (optional)
     * @param  string $templateId A template ID. (optional)
     * @param  string $commaDelimEmails Comma delimited emails (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVideoQuickSenderDataAsyncWithHttpInfo($message = null, $subject = null, $videoId = null, $templateId = null, $commaDelimEmails = null)
    {
        $returnType = '';
        $request = $this->getVideoQuickSenderDataRequest($message, $subject, $videoId, $templateId, $commaDelimEmails);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVideoQuickSenderData'
     *
     * @param  string $message A message for the video content. (optional)
     * @param  string $subject A subject for the video content. (optional)
     * @param  string $videoId A video ID. (optional)
     * @param  string $templateId A template ID. (optional)
     * @param  string $commaDelimEmails Comma delimited emails (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVideoQuickSenderDataRequest($message = null, $subject = null, $videoId = null, $templateId = null, $commaDelimEmails = null)
    {

        $resourcePath = '/emails/quicksend';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($message !== null) {
            $queryParams['message'] = ObjectSerializer::toQueryValue($message);
        }
        // query params
        if ($subject !== null) {
            $queryParams['subject'] = ObjectSerializer::toQueryValue($subject);
        }
        // query params
        if ($videoId !== null) {
            $queryParams['videoId'] = ObjectSerializer::toQueryValue($videoId);
        }
        // query params
        if ($templateId !== null) {
            $queryParams['templateId'] = ObjectSerializer::toQueryValue($templateId);
        }
        // query params
        if ($commaDelimEmails !== null) {
            $queryParams['commaDelimEmails'] = ObjectSerializer::toQueryValue($commaDelimEmails);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveQuickSenderSettings
     *
     * Save quicksender settings
     *
     * @param  string $alertOnPlay A preference setting for whether or not to notify user on quicksend email video plays. (optional)
     * @param  string $alertOnOpen A preference setting for whether or not to notify user on quicksend email opens. (optional)
     * @param  string $templateId Id of a template to use for this send. A null value means use the default for this user. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function saveQuickSenderSettings($alertOnPlay = null, $alertOnOpen = null, $templateId = null)
    {
        $this->saveQuickSenderSettingsWithHttpInfo($alertOnPlay, $alertOnOpen, $templateId);
    }

    /**
     * Operation saveQuickSenderSettingsWithHttpInfo
     *
     * Save quicksender settings
     *
     * @param  string $alertOnPlay A preference setting for whether or not to notify user on quicksend email video plays. (optional)
     * @param  string $alertOnOpen A preference setting for whether or not to notify user on quicksend email opens. (optional)
     * @param  string $templateId Id of a template to use for this send. A null value means use the default for this user. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveQuickSenderSettingsWithHttpInfo($alertOnPlay = null, $alertOnOpen = null, $templateId = null)
    {
        $returnType = '';
        $request = $this->saveQuickSenderSettingsRequest($alertOnPlay, $alertOnOpen, $templateId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation saveQuickSenderSettingsAsync
     *
     * Save quicksender settings
     *
     * @param  string $alertOnPlay A preference setting for whether or not to notify user on quicksend email video plays. (optional)
     * @param  string $alertOnOpen A preference setting for whether or not to notify user on quicksend email opens. (optional)
     * @param  string $templateId Id of a template to use for this send. A null value means use the default for this user. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveQuickSenderSettingsAsync($alertOnPlay = null, $alertOnOpen = null, $templateId = null)
    {
        return $this->saveQuickSenderSettingsAsyncWithHttpInfo($alertOnPlay, $alertOnOpen, $templateId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveQuickSenderSettingsAsyncWithHttpInfo
     *
     * Save quicksender settings
     *
     * @param  string $alertOnPlay A preference setting for whether or not to notify user on quicksend email video plays. (optional)
     * @param  string $alertOnOpen A preference setting for whether or not to notify user on quicksend email opens. (optional)
     * @param  string $templateId Id of a template to use for this send. A null value means use the default for this user. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveQuickSenderSettingsAsyncWithHttpInfo($alertOnPlay = null, $alertOnOpen = null, $templateId = null)
    {
        $returnType = '';
        $request = $this->saveQuickSenderSettingsRequest($alertOnPlay, $alertOnOpen, $templateId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveQuickSenderSettings'
     *
     * @param  string $alertOnPlay A preference setting for whether or not to notify user on quicksend email video plays. (optional)
     * @param  string $alertOnOpen A preference setting for whether or not to notify user on quicksend email opens. (optional)
     * @param  string $templateId Id of a template to use for this send. A null value means use the default for this user. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function saveQuickSenderSettingsRequest($alertOnPlay = null, $alertOnOpen = null, $templateId = null)
    {

        $resourcePath = '/emails/quicksend/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($alertOnPlay !== null) {
            $formParams['alertOnPlay'] = ObjectSerializer::toFormValue($alertOnPlay);
        }
        // form params
        if ($alertOnOpen !== null) {
            $formParams['alertOnOpen'] = ObjectSerializer::toFormValue($alertOnOpen);
        }
        // form params
        if ($templateId !== null) {
            $formParams['templateId'] = ObjectSerializer::toFormValue($templateId);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation videoQuickSender
     *
     * Send a quicksend email
     *
     * @param  string $videoId A guid id for the video. (optional)
     * @param  string $emailAddresses A semi-colon separated list of email addresses to send to. (optional)
     * @param  string $subject Subject line for the email. (optional)
     * @param  string $message Message for the body of the email. (optional)
     * @param  string $listIds An array of list ids (optional)
     * @param  int $scheduledSendTimestamp When to schedule the send (seconds since epoch). null value means send immediately. (optional)
     * @param  string $extendedProperties Bool value that when checked will send back both emailId as well as extra properties (optional)
     * @param  string $templateId Id of a template to use for this send. A null value means use the default for this user. (optional)
     * @param  string $stripHTML remove HTML elements (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function videoQuickSender($videoId = null, $emailAddresses = null, $subject = null, $message = null, $listIds = null, $scheduledSendTimestamp = null, $extendedProperties = null, $templateId = null, $stripHTML = null)
    {
        $this->videoQuickSenderWithHttpInfo($videoId, $emailAddresses, $subject, $message, $listIds, $scheduledSendTimestamp, $extendedProperties, $templateId, $stripHTML);
    }

    /**
     * Operation videoQuickSenderWithHttpInfo
     *
     * Send a quicksend email
     *
     * @param  string $videoId A guid id for the video. (optional)
     * @param  string $emailAddresses A semi-colon separated list of email addresses to send to. (optional)
     * @param  string $subject Subject line for the email. (optional)
     * @param  string $message Message for the body of the email. (optional)
     * @param  string $listIds An array of list ids (optional)
     * @param  int $scheduledSendTimestamp When to schedule the send (seconds since epoch). null value means send immediately. (optional)
     * @param  string $extendedProperties Bool value that when checked will send back both emailId as well as extra properties (optional)
     * @param  string $templateId Id of a template to use for this send. A null value means use the default for this user. (optional)
     * @param  string $stripHTML remove HTML elements (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function videoQuickSenderWithHttpInfo($videoId = null, $emailAddresses = null, $subject = null, $message = null, $listIds = null, $scheduledSendTimestamp = null, $extendedProperties = null, $templateId = null, $stripHTML = null)
    {
        $returnType = '';
        $request = $this->videoQuickSenderRequest($videoId, $emailAddresses, $subject, $message, $listIds, $scheduledSendTimestamp, $extendedProperties, $templateId, $stripHTML);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation videoQuickSenderAsync
     *
     * Send a quicksend email
     *
     * @param  string $videoId A guid id for the video. (optional)
     * @param  string $emailAddresses A semi-colon separated list of email addresses to send to. (optional)
     * @param  string $subject Subject line for the email. (optional)
     * @param  string $message Message for the body of the email. (optional)
     * @param  string $listIds An array of list ids (optional)
     * @param  int $scheduledSendTimestamp When to schedule the send (seconds since epoch). null value means send immediately. (optional)
     * @param  string $extendedProperties Bool value that when checked will send back both emailId as well as extra properties (optional)
     * @param  string $templateId Id of a template to use for this send. A null value means use the default for this user. (optional)
     * @param  string $stripHTML remove HTML elements (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function videoQuickSenderAsync($videoId = null, $emailAddresses = null, $subject = null, $message = null, $listIds = null, $scheduledSendTimestamp = null, $extendedProperties = null, $templateId = null, $stripHTML = null)
    {
        return $this->videoQuickSenderAsyncWithHttpInfo($videoId, $emailAddresses, $subject, $message, $listIds, $scheduledSendTimestamp, $extendedProperties, $templateId, $stripHTML)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation videoQuickSenderAsyncWithHttpInfo
     *
     * Send a quicksend email
     *
     * @param  string $videoId A guid id for the video. (optional)
     * @param  string $emailAddresses A semi-colon separated list of email addresses to send to. (optional)
     * @param  string $subject Subject line for the email. (optional)
     * @param  string $message Message for the body of the email. (optional)
     * @param  string $listIds An array of list ids (optional)
     * @param  int $scheduledSendTimestamp When to schedule the send (seconds since epoch). null value means send immediately. (optional)
     * @param  string $extendedProperties Bool value that when checked will send back both emailId as well as extra properties (optional)
     * @param  string $templateId Id of a template to use for this send. A null value means use the default for this user. (optional)
     * @param  string $stripHTML remove HTML elements (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function videoQuickSenderAsyncWithHttpInfo($videoId = null, $emailAddresses = null, $subject = null, $message = null, $listIds = null, $scheduledSendTimestamp = null, $extendedProperties = null, $templateId = null, $stripHTML = null)
    {
        $returnType = '';
        $request = $this->videoQuickSenderRequest($videoId, $emailAddresses, $subject, $message, $listIds, $scheduledSendTimestamp, $extendedProperties, $templateId, $stripHTML);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'videoQuickSender'
     *
     * @param  string $videoId A guid id for the video. (optional)
     * @param  string $emailAddresses A semi-colon separated list of email addresses to send to. (optional)
     * @param  string $subject Subject line for the email. (optional)
     * @param  string $message Message for the body of the email. (optional)
     * @param  string $listIds An array of list ids (optional)
     * @param  int $scheduledSendTimestamp When to schedule the send (seconds since epoch). null value means send immediately. (optional)
     * @param  string $extendedProperties Bool value that when checked will send back both emailId as well as extra properties (optional)
     * @param  string $templateId Id of a template to use for this send. A null value means use the default for this user. (optional)
     * @param  string $stripHTML remove HTML elements (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function videoQuickSenderRequest($videoId = null, $emailAddresses = null, $subject = null, $message = null, $listIds = null, $scheduledSendTimestamp = null, $extendedProperties = null, $templateId = null, $stripHTML = null)
    {

        $resourcePath = '/emails/quicksend';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($videoId !== null) {
            $formParams['videoId'] = ObjectSerializer::toFormValue($videoId);
        }
        // form params
        if ($emailAddresses !== null) {
            $formParams['emailAddresses'] = ObjectSerializer::toFormValue($emailAddresses);
        }
        // form params
        if ($subject !== null) {
            $formParams['subject'] = ObjectSerializer::toFormValue($subject);
        }
        // form params
        if ($message !== null) {
            $formParams['message'] = ObjectSerializer::toFormValue($message);
        }
        // form params
        if ($listIds !== null) {
            $formParams['listIds'] = ObjectSerializer::toFormValue($listIds);
        }
        // form params
        if ($scheduledSendTimestamp !== null) {
            $formParams['scheduledSendTimestamp'] = ObjectSerializer::toFormValue($scheduledSendTimestamp);
        }
        // form params
        if ($extendedProperties !== null) {
            $formParams['extendedProperties'] = ObjectSerializer::toFormValue($extendedProperties);
        }
        // form params
        if ($templateId !== null) {
            $formParams['templateId'] = ObjectSerializer::toFormValue($templateId);
        }
        // form params
        if ($stripHTML !== null) {
            $formParams['stripHTML'] = ObjectSerializer::toFormValue($stripHTML);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
